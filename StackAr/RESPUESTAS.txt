1)
a- Se generaron 75 mutantes
b- El operador que generó más mutantes es el FalseConditionalsMutator y TrueConditionalsMutator con 10 mutantes generados. [TODO: ¿Cuántos y por qué?]
c- Hubieron algunos operadores que no generaron ningún mutante: [TODO: ¿Cuántos y por qué?]
 - MathMutator
 - IncrementsMutator
 - NullReturns

2)
   Para el StackTests1:
 - sobrevivieron 59 mutantes
 - murieron 16
 - mutation score: 0.21333...
   Para el StackTests2:
 - sobrevivieron 44 mutantes
 - murieron 31
 - mutation score: 0.41333...

3) a y b)
   Para el StackTests3:
 - sobrevivieron 18 mutantes
 - murieron 57
 - mutation score: 0.76

c) De los 18 mutantes que sobrevivieron:
  - 13 son de la pinta reemplazar "1 por 1", "false por false" o similares, donde lo que se reemplaza es exactamente lo mismo que con lo que es reemplazado. Por lo que en estos casos la equivalencia es trivial.
  - StackArMutated7915 (MinusOneConstantMutator: Se reemplazó 31 por -1 en la línea 63.)
  - StackArMutated7845 (OneConstantMutator: Se reemplazó 31 por 1 en la línea 63.)
    + En esa linea se define el número primo base que codifica los hash codes. Como simplemente es un número fijo y no un primo aleatorio no modifica el comportamiento que tiene. No hay tests que verifiquen hash codes diferentes.
  - StackArMutated3162 (FalseConditionalsMutator: Se reemplazó this == obj por false en la línea 72.)
    + Queda un "if (false)" que hace que el código del cuerpo sea inalcanzable. Pero el código es equivalente porque el chequeo de "this == obj" queda cubierto por el "return true" default. Por lo que es un indicador de que es código fútil.
  - StackArMutated8173 (FalseConditionalsMutator: Se reemplazó isEmpty() por false en la línea 45.)
    + Hace que quede inalcanzable el throw de IllegalStateException del pop, pero como el método llama a top, el que va a tirar la excepción es top(). Por lo que el código es equivalente (no se puede crear un test que haga fallar a este mutante) y muestra que ese if es innecesario.
  - StackArMutated2163 (ZeroConstantMutator: Se reemplazó 1 por 0 en la línea 64.)
    + Quedan todos los hashcodes con offset 0 pero no es un problema porque siguen siendo hashcodes válidos y mantienen el comportamiento.

d) Para las clases mutadas (org.autotest.mutants) el instruction coverage promedio fue 65% (4,886 de 14,227).

e) El instruction coverage más bajo se logró con StackArMutated4116 en el que el coverage fue de apenas 4%. En este caso fue en un mutante que modificó la guarde de "capacity < 0" por true, por lo que siempre que el stack sea creado pasando una capacidad simplemente se arroja una excepción y no se utiliza ninguna otra instrucción del mutante.